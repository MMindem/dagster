---
title: Schedules | Dagster
description: Schedules are ...
---

# Schedules

Dagster includes a built-in scheduler that can be used to launch runs on a fixed interval.

<img src="/images/schedules.png" />

## Relevant APIs

| Name                                             | Description                                                                                                                                                                                      |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <PyObject object="daily_schedule" decorator />   | Decorator that defines a schedule that executes every day at a fixed time                                                                                                                        |
| <PyObject object="hourly_schedule" decorator />  | Decorator that defines a schedule that executes every hour at a fixed time                                                                                                                       |
| <PyObject object="weekly_schedule" decorator />  | Decorator that defines a schedule that executes every week on a fixed day and time                                                                                                               |
| <PyObject object="monthly_schedule" decorator /> | Decorator that defines a schedule that executes every month on a fixed day and time                                                                                                              |
| <PyObject object="schedule" decorator />         | Decorator that defines a schedule that executes according to a given cron schedule. It's important to note that schedules created using this schedule are [non-partition based schedules](#TODO) |
| <PyObject object="ScheduleExecutionContext" />   | The context passed to the schedule definition execution function                                                                                                                                 |
| <PyObject object="ScheduleDefinition"  />        | Base class for schedules. You almost never want to use initialize this class directly. Instead, you should use one of the many decorators above                                                  |

## Overview

A schedule is a definition in Dagster that targets a pipeline and is used to execute the pipeline on a fixed schedule. The definition itself is responsible for generating run configuration for the pipeline on each schedule tick. In order to run schedules, you will need to run the [dagster-daemon](#TODO) process.

Schedules have several important properties:

- Each schedule targets a specific pipeline
- A schedule defines a function that returns run configuration for the targeted pipeline.
- A schedule optionally defines tags, a mode, and a solid selection for the targeted pipeline.
- A schedule optionally defines a `should_execute` function, which can be used to skip a schedule execution based on an abitrary condition.

Dagster also includes a built in scheduler, the <PyObject object="DagsterDaemonScheduler"/>, which runs as a part of the dagster-daemon process. Once you have defined a schedule, see the [dagster-daemon](#TODO) page for instructions on how to run the daemon in order to execute your schedules.

---

## Defining a schedule

There are two tpes of schedules in Dagster:

- Partition based
- Non-partition based

(TODO): Small intro about how to decide whichs schedule to use

### Partition-based schedules

Partition-based schedules are schedules that generate an underlying <PyObject object="PartitionSetDefinition"/> to execute against. The scheduelr will make sure that a run will be executed for every partition in the partition set.

For example, if we wanted to create a schedule that runs at 11:00 AM every day, we could use the <PyObject object="daily_schedule" decorator />, which is a decorator that produced a partition-based daily schedule.

```python
@daily_schedule(
    pipeline_name="my_data_pipeline",
    start_date=datetime(2021, 1, 1),
    execution_time=time(11, 0),
    execution_timezone="US/Central",
)
def my_daily_schedule(date):
    return {"solids": {"process_data_for_date": {"config": {"date": date.strftime("%Y-%m-%d")}}}}
```

Partition-based schedules are useful when it's important for a successful run to exist for every scheduled run time. For example, if each run fills in a daily partition of a data warehouse table, basing your schedule on a partition set allows you to track which days have corresponding runs and fill in gaps when runs fail.

### Non-partition-based schedules

## Running the scheduler

## Examples

### Cron schedule

For use-cases where you want to run the schedule on a fixed cron interval and don't need partition based configuration, you can use the <PyObject object="schedule" decorator"/> decorator to define your schedule.

In this example, the schedule runs at 1:00 AM in US/Central every day

```python
@schedule(
    cron_schedule="0 1 * * *", pipeline_name="my_data_pipeline", execution_timezone="US/Central"
)  # Executes at 1:00 AM in US/Central time every day
def my_schedule(context):
    return {"solids": {"dataset_name": "my_dataset"}}
```

You can also access the execution time fron the context:

```python
@schedule(
    cron_schedule="0 1 * * *", pipeline_name="my_data_pipeline", execution_timezone="US/Central"
)  # Executes at 1:00 AM in US/Central time every day
def my_schedule(context):
    date = context.scheduled_execution_time.strftime("%Y-%m-%d")
    return {"solids": {"process_data_for_date": {"config": {"date": date}}}}`
```

### Hourly Schedule

### Daily Schedule

### Weekly Schedule

### Monthly Schedule

### Schedule from Custom Partition Set

If you have a unique scheduling requirement, you can define your own partition set and schedule definition using the base classes.

TODO

## Patterns

### Using a preset in a schedule definition

If you already have a preset defined for a pipeline you want to schedule, you can extract the necessary attributes from the preset and pass them to the schedule decorator.

In this example, we directly use the `solid_selection`, `mode`, `tags`, and `run_config` from the preset:

```python
@daily_schedule(
    start_date=...,
    pipeline_name="my_pipeline",
    solid_selection=preset.solid_selection,
    mode=preset.mode,
    tags_fn_for_date=lambda _: preset.tags,
)
def my_daily_schedule(_date):
    return preset.run_config
```

You might need to modify the preset's run config to include information about the date partition the schedule is running for. You can use the `merge_dicts` util to inject the date:

```python
@daily_schedule(
    start_date=...,
    pipeline_name="my_pipeline",
    solid_selection=preset.solid_selection,
    mode=preset.mode,
    tags_fn_for_date=lambda _: preset.tags,
)
def my_daily_schedule(_date):
    return merge_dicts(preset.run_config, {"date": date.strftime("%Y-%m-%d")}}
```

If you find yourself using presets to generate schedule definitions frequently, you can use a helper function similar to this one to take a preset and return a schedule.

```python
from dagster import check, PipelineDefinition, DagsterInvalidDefinitionError, daily_schedule
import datetime


def daily_schedule_definition_from_pipeline_preset(pipeline, preset_name, start_date):
    check.inst_param(pipeline, "pipeline", PipelineDefinition)
    check.str_param(preset_name, "preset_name")
    check.inst_param(start_date, "start_date", datetime.datetime)

    preset = pipeline.get_preset(preset_name)
    if not preset:
        raise DagsterInvalidDefinitionError(
            "Preset {preset_name} was not found "
            "on pipeline {pipeline_name}".format(
                preset_name=preset_name, pipeline_name=pipeline.name
            )
        )

    @daily_schedule(
        start_date=start_date,
        pipeline_name=pipeline.name,
        solid_selection=preset.solid_selection,
        mode=preset.mode,
        tags_fn_for_date=lambda _: preset.tags,
    )
    def my_daily_schedule(_date):
        return preset.run_config

    return my_daily_schedule
```
